import React, { useEffect, useState, useRef } from "react";

import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Checkbox,
  FormControlLabel,
  CircularProgress, // For loading indicator
} from "@mui/material";

import { DataGrid } from "@mui/x-data-grid";
import gsap from "gsap";

const flattenHierarchy = (node, allItems = []) => {
  if (!node) return;
  console.log("Node content :", node);
  const nodeHierarchy = Array.isArray(node.hierarchy) ? node.hierarchy : [];
  if (node.originalLevel !== undefined) {
    allItems.push({
      id: nodeHierarchy.length > 0
        ? nodeHierarchy.join('::')
        : `${node.text || 'unknown-component'}-${Math.random().toString(36).substring(2, 9)}`,
      text: node.text,
      path: node.path,
      hierarchy: nodeHierarchy,
      originalLevel: node.originalLevel,
      dat_template: node.dat_template,
      Mandatory_Objects: node.Mandatory_Objects,
      file: node.file,
      // Initialize isSelected based on Mandatory_Objects
      isSelected: node.Mandatory_Objects,
      level_1: node.level_1,
      level_2: node.level_2,
      level_3: node.level_3,
      level_4: node.level_4,
      level_5: node.level_5,
      level_6: node.level_6,
      level_7: node.level_7,
      level_8: node.level_8,
    });
  }

  if (node.children && Array.isArray(node.children)) {
    node.children.forEach(child => flattenHierarchy(child, allItems));
  }
  return allItems;
};

// Define apiEndpoint here as it's needed within BundleUp
const apiEndpoint = process.env.REACT_APP_API_ENDPOINT;

// Updated component signature to include customerName and instanceName
const BundleUp = ({ open, onClose, itemData, onShowSnackbar, customerName, instanceName }) => {
  const [rows, setRows] = useState([]);
  const [isBundling, setIsBundling] = useState(false);
  const dialogRef = useRef(null);

  useEffect(() => {
    if (open && itemData) {
      gsap.fromTo(
        dialogRef.current,
        { opacity: 0, scale: 0.9 },
        { opacity: 1, scale: 1, duration: 0.3, ease: "back.out(1.2)" }
      );
      const allBundlableItems = flattenHierarchy(itemData);
      // Initialize items: only mandatory objects are selected by default
      setRows(allBundlableItems.map(row => ({ ...row, isSelected: row.Mandatory_Objects })));
    } else if (!open) {
      setRows([]);
      setIsBundling(false);
    }
  }, [open, itemData]);

  const handleCheckboxChange = (id) => {
    setRows((prevRows) =>
      prevRows.map((row) =>
        row.id === id ? { ...row, isSelected: !row.isSelected } : row
      )
    );
  };

  const handleSelectAllChange = (event) => {
    const checked = event.target.checked;
    setRows((prevRows) =>
      prevRows.map((row) => ({ ...row, isSelected: checked }))
    );
  };

  const performBundling = async (selectedItems, customerName, instanceName) => {
    const storedValidationSession = sessionStorage.getItem('validationSession');
    const BundleValidationSession = sessionStorage.getItem('bulkValidationSession');
    let currentValidationSession = storedValidationSession ? JSON.parse(storedValidationSession) : {};
    let bundleSession = BundleValidationSession ? JSON.parse(BundleValidationSession) : {};

    const filesToBundle = [];
    const notValidatedOrMissingFile = [];

    selectedItems.forEach(item => {
      const sessionData = currentValidationSession[item.text];
      if (sessionData?.validated && sessionData?.fileName) {
        filesToBundle.push(sessionData.fileName);
      } else {
        notValidatedOrMissingFile.push(item.text);
      }
    });

    if (notValidatedOrMissingFile.length > 0) {
      onShowSnackbar(`Components not validated or missing file data: ${notValidatedOrMissingFile.join(', ')}`, "warning");
      console.log("Bulk DAT download prevented. Issues with:", notValidatedOrMissingFile);
      return false;
    }

    if (filesToBundle.length === 0) {
      onShowSnackbar("No validated components with file data were selected.", "info");
      return false;
    }

    try {
      onShowSnackbar(`Requesting DAT file bundle for ${filesToBundle.length} components...`, "info");
      const response = await fetch(`${apiEndpoint}/api/hdl/download-bundle`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ files: filesToBundle }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Server responded with status ${response.status}: ${errorText}`);
      }

      const responseData = await response.json();
      const bundles = responseData.bundles;

      if (!bundles || bundles.length === 0) {
        onShowSnackbar("No bundles were generated by the server.", "warning");
        return false;
      }

      onShowSnackbar(`Generated ${bundles.length} bundle(s). Starting downloads...`, "success");
      let allDownloadsSuccessful = true;
      let downloadedBundleDetails = [];

      for (const bundle of bundles) {
        const { filename, url, group } = bundle;
        if (url && filename) {
          try {
            const fileResponse = await fetch(`${apiEndpoint}${url}`);
            if (!fileResponse.ok) throw new Error(`Failed to download ${filename} (status ${fileResponse.status})`);
            const blob = await fileResponse.blob();
            const downloadUrl = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(downloadUrl);
            onShowSnackbar(`Successfully downloaded ${filename}!`, "success");

            downloadedBundleDetails.push({ filename, group });

            // âœ… POST DAT info to backend for each downloaded bundle
            const newJob = {
              id: Date.now(),
              component:itemData?.text || 'N/A', 
              fileName: filename,
              timeCreated: new Date().toISOString(),
              status: 'DAT Generated',
              contentId: null,
              requestId: null,
              oracleJobSummary: null,
            };

            // Using customerName and instanceName passed into the function
            await fetch(`${apiEndpoint}/api/hdl/getdata/${customerName}/${instanceName}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(newJob),
            });

            console.log("DAT info successfully posted to backend:", newJob);

          } catch (downloadError) {
            console.error(`Error downloading ${filename}:`, downloadError);
            onShowSnackbar(`Failed to download ${filename}: ${downloadError.message}`, "error");
            allDownloadsSuccessful = false;
          }
        } else {
          console.warn("Invalid bundle data (missing filename or url) for a bundle. Skipping download.");
          onShowSnackbar(`Invalid bundle data for a file. Skipping download.`, "warning");
          allDownloadsSuccessful = false;
        }
      }

      if (itemData?.text && downloadedBundleDetails.length > 0) {
        bundleSession[itemData.text] = {
          validated: true,
          bundles: downloadedBundleDetails
        };
        sessionStorage.setItem('bulkValidationSession', JSON.stringify(bundleSession));
      }

      return allDownloadsSuccessful;
    } catch (error) {
      console.error("Error during bulk DAT bundling process:", error);
      onShowSnackbar(`Failed to create or download DAT bundles: ${error.message}`, "error");
      return false;
    }
  };


  const handleOracleUpload = async (file) => {
    // This function remains unchanged as per your request that checks for mandatory items are not needed for bulk API calls.
    setIsBundling(true); // Indicate bundling/uploading is in progress
    onShowSnackbar("Initiating Cloud Upload...", "info");
    try {
      await new Promise((resolve) => setTimeout(resolve, 2000)); // Simulate API call
      console.log("Starting cloud upload for selected items:", rows.filter(row => row.isSelected));
      onShowSnackbar("Cloud Upload successful!", "success");
    } catch (error) {
      console.error("Cloud Upload failed:", error);
      onShowSnackbar(`Cloud Upload failed: ${error.message || 'Unknown error'}`, "error");
    } finally {
      setIsBundling(false);
      // If performBundling handles onClose() on success, remove it here
      // If you want to close the dialog regardless of bundling success after Oracle upload
      // onClose();
    }
  };

  // Updated function signature
  const handleBundleUp = async (customerName, instanceName) => {
    const selectedItems = rows.filter((row) => row.isSelected);
    // This function remains unchanged as per your request that checks for mandatory items are not needed for bulk API calls.
    if (selectedItems.length === 0) {
      onShowSnackbar("Please select at least one item to bundle.", "warning");
      return;
    }

    setIsBundling(true);
    // Pass customerName and instanceName to performBundling
    const bundleSuccess = await performBundling(selectedItems, customerName, instanceName);
    if (bundleSuccess) {
      onClose();
    }
    setIsBundling(false); // In case bundling failed
  };

  const columns = [
    {
      field: "selection",
      headerName: (
        <FormControlLabel
          control={
            <Checkbox
              checked={rows.length > 0 && rows.every((row) => row.isSelected)}
              indeterminate={rows.some((row) => row.isSelected) && !rows.every((row) => row.isSelected)}
              onChange={handleSelectAllChange}
              sx={{ color: '#000000' }}
            />
          }
          label="Select"
          sx={{ '& .MuiTypography-root': { color: '#000000' } }}
        />
      ),
      width: 120,
      sortable: false,
      renderCell: (params) => (
        <Checkbox
          checked={params.row.isSelected}
          onChange={() => handleCheckboxChange(params.row.id)}
          sx={{ color: '#000000' }}
        />
      ),
    },
    { field: "text", headerName: "Component Name", width: 250 },
    {
      field: "Mandatory_Objects",
      headerName: "Mandatory",
      width: 100,
      type: "boolean",
      renderCell: (params) => (
        <Typography sx={{ color: params.value ? '#d35400' : '#000000' }}>
          {params.value ? 'Yes' : 'No'}
        </Typography>
      ),
    },
    { field: "dat_template", headerName: "DAT Template", minWidth: 180 },
  ];

  const hasSelectedItems = rows.some(row => row.isSelected);

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="md"
      fullWidth
      ref={dialogRef}
      sx={{
        '& .MuiPaper-root': {
          backgroundColor: '#FFFFFF',
          color: '#000000',
          borderRadius: 2,
          boxShadow: '0 8px 32px 0 rgba(0,0,0,0.4)',
        },
        '& .MuiDialogTitle-root': {
          backgroundColor: '#F5F5F5',
          color: '#000000',
          borderBottom: '1px solid #E0E0E0',
        },
        '& .MuiDialogContent-dividers': {
          borderColor: '#E0E0E0',
        },
      }}
    >
      {/* Display customerName and instanceName here */}
      <DialogTitle sx={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap' }}>
        Generate Final HDL for:
        <Box component="span" sx={{ fontWeight: 'bold', color: '#1976d2', ml: 1 }}>{itemData?.text}</Box>
        <Box component="span" sx={{
          fontWeight: 'normal',
          fontSize: '0.9em',
          color: '#606060',
          ml: 2,
          mt: { xs: 1, sm: 0 } // responsive margin for better mobile view
        }}>
          (Customer: <Box component="span" sx={{ fontWeight: 'bold', color: '#000000' }}>{customerName}</Box> / Instance: <Box component="span" sx={{ fontWeight: 'bold', color: '#000000' }}>{instanceName}</Box>)
        </Box>
      </DialogTitle>
      <DialogContent dividers sx={{ p: 0 }}>
        <Box sx={{ p: 3, borderBottom: '1px solid #E0E0E0' }}>
          <Typography variant="body1" color="#000000">
            Select all the validated components that you want to include in the DAT file.
          </Typography>
        </Box>
        {rows.length > 0 ? (
          <Box sx={{
            height: 400,
            width: "100%",
            backgroundColor: '#FFFFFF',
            '& .MuiDataGrid-root': {
              border: 'none',
              color: '#000000',
              '& .MuiDataGrid-columnHeaders': {
                backgroundColor: '#E0E0E0',
                color: '#000000',
                borderBottom: '1px solid #C0C0C0',
              },
              '& .MuiDataGrid-columnHeaderTitle': {
                fontWeight: 'bold',
              },
              '& .MuiDataGrid-row': {
                '&:nth-of-type(even)': {
                  backgroundColor: '#FAFAFA',
                },
                '&:hover': {
                  backgroundColor: '#E8E8E8',
                },
              },
              '& .MuiDataGrid-cell': {
                borderColor: '#E0E0E0',
              },
              '& .MuiTablePagination-root': {
                color: '#000000',
              },
              '& .MuiSvgIcon-root': {
                color: '#000000',
              },
              '& .MuiDataGrid-checkboxInput': {
                color: '#000000',
              },
              '& .MuiDataGrid-sortIcon': {
                color: '#000000',
              },
              '& .Mui-checked': {
                color: '#1976d2 !important',
              },
              '& .MuiCheckbox-indeterminate': {
                color: '#1976d2 !important',
              }
            },
          }}>
            <DataGrid
              rows={rows}
              columns={columns}
              pageSizeOptions={[5, 10, 20]}
              initialState={{
                pagination: {
                  paginationModel: {
                    pageSize: 5,
                  },
                },
              }}
              disableRowSelectionOnClick
              rowHeight={48}
            />
          </Box>
        ) : (
          <Box sx={{ p: 3, textAlign: 'center' }}>
            <Typography variant="body1" color="#000000">
              No descendant components found for this item.
            </Typography>
            <Typography variant="body2" color="#000000" mt={1}>
              The "Download Bulk DAT" functionality applies to items with children.
            </Typography>
          </Box>
        )}
      </DialogContent>
      <DialogActions sx={{ p: 2, borderTop: '1px solid #E0E0E0' }}>
        <Button
          onClick={onClose}
          variant="contained"
          sx={{
            minWidth: 120,
            bgcolor: '#1976d2',
            color: '#FFFFFF',
            '&:hover': { bgcolor: '#1565c0' },
            '&.Mui-disabled': {
              bgcolor: 'rgba(25,118,210,0.5)',
              color: 'rgba(255,255,255,0.7)',
            }
          }}>
          Cancel
        </Button>
        <Box sx={{ flexGrow: 1 }} /> {/* This pushes the following buttons to the right */}
        <Button
          onClick={() => handleBundleUp(customerName, instanceName)} // Pass customerName and instanceName
          variant="contained"
          disabled={isBundling || !hasSelectedItems}
          sx={{
            minWidth: 120,
            bgcolor: '#1976d2',
            color: '#FFFFFF',
            '&:hover': { bgcolor: '#1565c0' },
            '&.Mui-disabled': {
              bgcolor: 'rgba(25,118,210,0.5)',
              color: 'rgba(255,255,255,0.7)',
            }
          }}
        >
          {isBundling ? <CircularProgress size={24} color="inherit" /> : "Generate Final HDL"}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default BundleUp;
